# OneDrive Sync — Implementation Plan

## Overview

Sync saved Transmogrifier articles across devices using OneDrive via the Microsoft Graph API. Articles are stored as HTML files in the user's OneDrive `AppData` folder (invisible to the user, scoped to the app). Metadata is synced via `chrome.storage.sync` for fast listing without downloading full content.

---

## Architecture

```
┌──────────────┐    chrome.storage.sync     ┌──────────────┐
│   Device A   │  ◄──────────────────────►  │   Device B   │
│  IndexedDB   │    (article metadata)      │  IndexedDB   │
│  (full HTML) │                            │  (full HTML) │
└──────┬───────┘                            └──────┬───────┘
       │                                           │
       │         Microsoft Graph API               │
       └──────►  OneDrive AppData  ◄───────────────┘
                /Transmogrifier/articles/
                  {id}.html
                  {id}.json  (metadata)
```

### Storage Roles

| Store | What | Why |
|---|---|---|
| **IndexedDB** (local) | Full article HTML + metadata | Fast offline access, no size limits |
| **chrome.storage.sync** | Article index (id, title, url, recipe, timestamp) | Instant cross-device list, triggers `onChanged` events |
| **OneDrive AppData** | Full article HTML + metadata JSON | Cross-device content sync, persistent cloud backup |

---

## Auth Flow

### App Registration
- Register in Azure Portal → App Registrations
- Platform: SPA (browser extension)
- Redirect URI: `https://<extension-id>.chromiumapp.org/` (generated by `chrome.identity.getRedirectURL()`)
- Scopes: `Files.ReadWrite.AppFolder`, `User.Read`, `offline_access`

### Token Acquisition (in service worker)
1. Use `chrome.identity.launchWebAuthFlow({ interactive: true })` 
2. Redirect to `https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize`
3. Use PKCE (no client secret — public client)
4. Store tokens in `chrome.storage.session` (encrypted, session-scoped)
5. Refresh silently via `launchWebAuthFlow({ interactive: false })` or refresh token

### Token Refresh
- Access tokens expire in ~1 hour
- Use refresh token for silent renewal
- Fall back to interactive if refresh fails

---

## OneDrive Storage Layout

```
/drive/special/approot/           ← App-scoped, invisible to user
  articles/
    article_1738800000_abc1234.json    ← metadata
    article_1738800000_abc1234.html    ← full content
    article_1738800000_def5678.json
    article_1738800000_def5678.html
  sync-state.json                      ← last sync timestamps
```

### Graph API Endpoints

| Operation | Method | Endpoint |
|---|---|---|
| Create app folder | PUT | `/me/drive/special/approot:/Transmogrifier/articles` |
| Upload article | PUT | `/me/drive/special/approot:/Transmogrifier/articles/{id}.html:/content` |
| Upload metadata | PUT | `/me/drive/special/approot:/Transmogrifier/articles/{id}.json:/content` |
| List articles | GET | `/me/drive/special/approot:/Transmogrifier/articles:/children` |
| Download article | GET | `/me/drive/special/approot:/Transmogrifier/articles/{id}.html:/content` |
| Delete article | DELETE | `/me/drive/special/approot:/Transmogrifier/articles/{id}.html` |
| Delta (changes) | GET | `/me/drive/special/approot:/Transmogrifier/articles:/delta` |

The **delta** endpoint is key — it returns only items changed since the last check, making ongoing sync cheap.

---

## New Files

```
src/shared/
  onedrive-service.ts     ← Graph API client (upload, download, delta)
  auth-service.ts         ← MSA OAuth2 + PKCE + token management
  sync-service.ts         ← Sync orchestrator (merge, conflict resolution)
```

---

## Sync Logic

### Phase 1: Upload on Save
When an article is saved locally:
1. Save to IndexedDB (existing flow)
2. Push article metadata to `chrome.storage.sync` (capped index)
3. If signed in → upload `{id}.html` + `{id}.json` to OneDrive in background

### Phase 2: Pull on Open / Periodic Sync  
When the popup opens or periodically (alarm):
1. Call delta endpoint to get changed files since last sync
2. For each new/updated remote article:
   - Download `{id}.json` metadata
   - Insert into local `chrome.storage.sync` index
   - **Don't** download HTML yet (lazy — only when user opens it)
3. For each locally deleted article:
   - Delete from OneDrive

### Phase 3: Lazy Content Download
When user opens an article that exists in the sync index but not in local IndexedDB:
1. Show a "Downloading from cloud..." spinner
2. Download `{id}.html` from OneDrive
3. Save to local IndexedDB
4. Display normally

### Conflict Resolution
Simple **last-write-wins** based on `updatedAt` timestamp:
- If remote `updatedAt` > local `updatedAt` → remote wins
- If local `updatedAt` > remote `updatedAt` → local wins (re-upload)
- Deletes propagate in both directions

---

## Manifest Changes

```json
{
  "permissions": [
    "identity",          // NEW — for launchWebAuthFlow
    "alarms",            // NEW — for periodic sync
    "activeTab",
    "storage",
    "scripting",
    "downloads"
  ],
  "host_permissions": [
    "<all_urls>",
    "https://graph.microsoft.com/*",    // NEW — Graph API
    "https://login.microsoftonline.com/*"  // NEW — Auth
  ],
  "oauth2": {
    "client_id": "<AZURE_APP_CLIENT_ID>",
    "scopes": ["Files.ReadWrite.AppFolder", "User.Read", "offline_access"]
  }
}
```

---

## UI Changes

### Popup — Settings/Account Section
Add a small account area (gear icon in header or settings panel):
- **Signed out**: "Sign in with Microsoft to sync articles across devices" + Sign In button
- **Signed in**: User display name/email, sync status, "Sign Out" button
- **Syncing**: Spinner with "Syncing..." text

### Saved Articles Tab
- Cloud icon badge on articles that exist remotely but aren't downloaded locally
- "↓ Download" indicator for cloud-only articles
- Sync status indicator in the header: "Last synced 2m ago" or "Offline"

### Viewer Page  
- No changes needed — viewer already reads from IndexedDB

---

## chrome.storage.sync Index Format

```typescript
// Stored under key "articleIndex" in chrome.storage.sync
// Max 8KB per key, ~100KB total for sync storage
interface SyncedArticleIndex {
  articles: SyncedArticleMeta[];
  lastSyncTime: number;
}

interface SyncedArticleMeta {
  id: string;
  title: string;           // truncated to 100 chars
  originalUrl: string;
  recipeId: string;
  recipeName: string;
  createdAt: number;
  updatedAt: number;
  isFavorite: boolean;
  size: number;
  // No HTML, no thumbnail — too large for sync storage
}
```

At ~200 bytes per entry, this supports ~400 articles within the 100KB sync limit.

---

## Implementation Phases

### Phase 1 — Auth + Basic Upload (MVP)
1. Azure App Registration + client ID config
2. `auth-service.ts`: PKCE auth flow, token storage, refresh
3. `onedrive-service.ts`: upload file, download file, list files
4. Hook into `saveArticle()` → upload to OneDrive after local save
5. Sign in/out UI in popup
6. **Estimated effort: 2–3 days**

### Phase 2 — Sync Down + Delta
1. `sync-service.ts`: delta-based sync, merge logic
2. Periodic sync via `chrome.alarms` (every 15 min)
3. Sync on popup open
4. Lazy download of article content
5. Cloud badge UI on articles list
6. **Estimated effort: 2–3 days**

### Phase 3 — Full Bidirectional Sync
1. Delete propagation (local → cloud, cloud → local)
2. Conflict resolution (last-write-wins)
3. Favorite/metadata updates sync
4. Respin updates sync
5. "Last synced" status display
6. **Estimated effort: 1–2 days**

### Phase 4 — Polish
1. Error handling: offline, quota exceeded, auth expired
2. Retry with exponential backoff
3. Progress indicator for bulk sync
4. Settings: enable/disable sync toggle
5. **Estimated effort: 1–2 days**

---

## Key Risks & Mitigations

| Risk | Mitigation |
|---|---|
| Articles too large for Graph upload (>4MB) | Use upload session API for large files |
| User hits OneDrive quota | Check quota before upload, show warning |
| Service worker suspended mid-sync | Use `chrome.alarms` to resume; sync state stored in `chrome.storage.local` |
| Token refresh fails silently | Detect 401, clear tokens, show "Sign in again" prompt |
| Rate limiting (Graph API) | Batch requests, respect `Retry-After` headers |
| Sync conflicts on rapid edits | Last-write-wins is good enough for this use case |

---

## Dependencies

- **Azure App Registration** (free with any Microsoft account)
- **No new npm packages** — all done with `fetch()` + `chrome.identity`
- **No backend server** — pure client-side OAuth2 with PKCE
